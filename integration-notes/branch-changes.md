# OpenExpress Development Guide

This guide provides details on the development workflow, branching, environment variables, and architectural patterns used in the OpenExpress project.

## 1. Development Workflow & Branching

Our workflow is designed to be flexible, supporting development both locally and in cloud-based environments like Gemini AI Studio.

-   **Branching Strategy**: The `main` branch contains the latest stable code. All new work should be done on a feature branch created from `main`.
    -   Use a descriptive name, e.g., `feature/add-canvas-animations`.
-   **Local Development**: Use the `tasts_py.txt` task runner for common tasks. Ensure your `secrets/.env` file is configured correctly.
-   **Pull Requests**: Open pull requests against `main`. Describe your changes clearly.

## 2. Environment Variable Management

Consistent variable management is key to switching between local, AI Studio, and Vercel environments.

-   **Standard Names**: We use a standard set of variable names across all platforms. See `.env.example.txt` for the complete list.
    -   `API_KEY`: Gemini API Key
    -   `JWT_SECRET`: Secret for signing JSON Web Tokens.
    -   `PORT`: Server port (e.g., 8080 for Python, 3001 for Node).
-   **Local Secrets**: All secret keys for local development must be placed in a file at `/secrets/.env`. This file is git-ignored.
-   **Vercel/Cloud Deployment**: Environment variables must be configured in the platform's project settings dashboard.

## 3. Backend Architecture

The application uses a dual-backend approach to separate concerns:

-   **Python/Flask Server (`server/server_py.txt`)**:
    -   **Responsibility**: Core application logic.
    -   Handles interactions with the Google Gemini API via the `/api/ai-suggestions` endpoint.
    -   Provides data endpoints like `/api/save-design`.
    -   **Authentication**: Secures endpoints by validating JWTs generated by the Node.js server.

-   **Node.js/Express Server (`server/auth.js`)**:
    -   **Responsibility**: Manages all third-party OAuth 2.0 flows (Meta, X, etc.).
    -   **Authentication**: Upon successful login with a platform, it generates a JWT containing user info and sends it to the frontend.
    -   This isolates the complexity of OAuth from the main application logic.

## 4. Frontend API Integration

-   **AI Service (`services/geminiService.ts`)**: All calls to the Gemini API are proxied through our Python backend. The frontend calls our `/api/ai-suggestions` endpoint. This keeps the `GEMINI_API_KEY` secure on the server.
-   **Authenticated Calls**: Any request requiring user authentication (e.g., saving a design, scheduling a post) must include the JWT in the `Authorization` header as a Bearer token.
