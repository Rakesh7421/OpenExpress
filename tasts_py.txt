import os
import subprocess
import platform
import threading
import sys
import json
import atexit
from typing import List, Optional
import getpass

# --- Configuration ---
ROOT_DIR = os.path.dirname(os.path.abspath(__file__))
SERVER_DIR = os.path.join(ROOT_DIR, 'server')
FRONTEND_DIR = ROOT_DIR

PYTHON_SERVER_SCRIPT_TXT = os.path.join(SERVER_DIR, 'server_py.txt')
PACKAGE_JSON = os.path.join(ROOT_DIR, 'package.json')

# --- Helper Functions ---

def get_python_executable():
    """Returns the path to the python executable, with special handling for user 'Tempo'."""
    try:
        # Use getpass.getuser() for better compatibility across environments
        if getpass.getuser().lower() == 'tempo' and platform.system() == 'Windows':
            # The user provided `/d/`, which often means `D:` in MSYS/Git Bash environments.
            # We will construct the standard Windows path.
            custom_path = os.path.join('D:\\', 'installer_files', '.venv', 'Scripts', 'python.exe')
            if os.path.exists(custom_path):
                print(f"Info: Using custom Python executable for user 'Tempo': {custom_path}")
                return custom_path
            else:
                print(f"Warning: Custom Python path for 'Tempo' not found at '{custom_path}'. Falling back to default.")
    except Exception as e:
        print(f"Warning: Could not get username or check custom path. Reason: {e}. Falling back to default.")
    
    return sys.executable

PYTHON_EXECUTABLE = get_python_executable()


def print_header(title: str):
    """Prints a styled header."""
    print("\n" + "=" * 50)
    print(f"üöÄ {title}")
    print("=" * 50)

def prepare_package_json():
    """Ensures package.json exists, creating it from a default structure if needed."""
    if os.path.exists(PACKAGE_JSON):
        return True

    print(f"Info: '{os.path.basename(PACKAGE_JSON)}' not found. Creating a default package.json...")
    
    default_package_content = {
      "name": "openexpress-app",
      "version": "1.0.0",
      "description": "A UI for a design and content creation app.",
      "main": "index.js",
      "type": "module",
      "scripts": {
        "dev": "vite",
        "build": "vite build",
        "vercel-build": "cp api/index_py.txt api/index.py"
      },
      "author": "",
      "license": "ISC",
       "dependencies": {}
    }

    try:
        with open(PACKAGE_JSON, 'w', encoding='utf-8') as f:
            json.dump(default_package_content, f, indent=2)
        print(f"Successfully created '{os.path.relpath(PACKAGE_JSON, ROOT_DIR)}'.")
        return True
    except Exception as e:
        print(f"Error: Could not create package.json. Reason: {e}")
        return False


def run_command(command: List[str], working_dir: str, name: str, env: Optional[dict] = None):
    """Runs a command in a subprocess and streams its output."""
    print(f"[{name}] Starting process: {' '.join(command)}")
    try:
        use_shell = platform.system() == 'Windows'
        process = subprocess.Popen(
            command, cwd=working_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            text=True, encoding='utf-8', errors='replace', env=env, shell=use_shell
        )
        def stream_output(pipe, prefix):
            if pipe:
                for line in iter(pipe.readline, ''):
                    print(f"{prefix} {line}", end='')
        
        stdout_thread = threading.Thread(target=stream_output, args=(process.stdout, f"[{name}]"))
        stderr_thread = threading.Thread(target=stream_output, args=(process.stderr, f"[{name}-ERR]"))
        stdout_thread.start()
        stderr_thread.start()
        process.wait()
        stdout_thread.join()
        stderr_thread.join()
        print(f"[{name}] Process finished with exit code {process.returncode}.")
    except FileNotFoundError:
        print(f"[{name}-ERR] Command not found: {command[0]}. Is it installed and in your PATH?")
    except Exception as e:
        print(f"[{name}-ERR] An error occurred: {e}")

# --- Task Functions ---

def install_dependencies():
    """Installs both Python and Node.js dependencies."""
    print_header("Installing Dependencies")
    
    print("\n--- Installing Python dependencies ---")
    run_command([PYTHON_EXECUTABLE, '-m', 'pip', 'install', '-r', 'requirements.txt'], SERVER_DIR, "pip-server")
    run_command([PYTHON_EXECUTABLE, '-m', 'pip', 'install', '-r', 'requirements.txt'], ROOT_DIR, "pip-vercel")
    
    print("\n--- Installing Node.js dependencies ---")
    if not prepare_package_json():
        print("[npm-ERR] Could not prepare package.json for Node.js. Skipping npm install.")
        return
    run_command(['npm', 'install'], FRONTEND_DIR, "npm")

def run_python_server():
    """Runs the Python/Flask API & Auth server."""
    print_header("Running Python API & Auth Server")
    if not os.path.exists(PYTHON_SERVER_SCRIPT_TXT):
        print(f"[Python API-ERR] Source file not found: {os.path.relpath(PYTHON_SERVER_SCRIPT_TXT, ROOT_DIR)}")
        return
    
    # Run the .txt file directly with the Python interpreter
    run_command([PYTHON_EXECUTABLE, PYTHON_SERVER_SCRIPT_TXT], SERVER_DIR, "Python API")

def run_frontend_dev_server():
    """Runs the frontend development server (Vite)."""
    print_header("Running Frontend Dev Server")
    if not os.path.exists(PACKAGE_JSON):
        print("[Frontend-ERR] package.json not found. Cannot start. Try running 'Install Dependencies' first.")
        return
    run_command(['npm', 'run', 'dev'], FRONTEND_DIR, "Frontend")

def run_all_services():
    """Runs all services concurrently in separate threads."""
    print_header("Starting All Services")

    node_modules_path = os.path.join(FRONTEND_DIR, 'node_modules')
    if not os.path.isdir(node_modules_path):
        print("\nInfo: 'node_modules' directory not found. Running dependency installation first.")
        install_dependencies()
        if not os.path.isdir(node_modules_path):
            print("\nError: Dependency installation failed. Cannot start services.")
            return

    if not os.path.exists(PYTHON_SERVER_SCRIPT_TXT):
         print("\nRequired Python server script is missing. Run 'Check Environment' for details.")
         return

    threads = [
        threading.Thread(target=run_python_server),
        threading.Thread(target=run_frontend_dev_server)
    ]
    
    for t in threads:
        t.start()
    
    try:
        for t in threads:
            t.join()
    except KeyboardInterrupt:
        print("\nCaught KeyboardInterrupt, stopping services...")

def check_environment():
    """Checks for necessary files and configurations."""
    print_header("Checking Environment")
    
    pkg_json_ok = prepare_package_json()

    checks = {
        "Python Server Source (server_py.txt)": os.path.exists(PYTHON_SERVER_SCRIPT_TXT),
        "package.json in root": pkg_json_ok,
        "Python requirements.txt (server)": os.path.exists(os.path.join(SERVER_DIR, 'requirements.txt')),
        "Python requirements.txt (vercel)": os.path.exists(os.path.join(ROOT_DIR, 'requirements.txt')),
        "Secrets .env file": os.path.exists(os.path.join(ROOT_DIR, 'secrets', '.env')),
    }
    
    print("\n--- Status Report ---")
    all_ok = all(checks.values())
    for check, result in checks.items():
        print(f"- {check}: {'‚úÖ OK' if result else '‚ùå FAILED / MISSING'}")
    
    if not checks["Secrets .env file"]:
        print("\nWarning: No 'secrets/.env' file found. Servers might not work correctly without API keys.")
    
    if all_ok:
        print("\nEnvironment check successful!")
    else:
        print("\nSome environment checks failed. Please review the messages above.")

def main():
    """Main function to display the menu and handle user input."""
    menu = {
        '1': ('Install Dependencies', install_dependencies),
        '2': ('Run Python API & Auth Server', run_python_server),
        '3': ('Run Frontend Dev Server', run_frontend_dev_server),
        '4': ('Run All Services (Concurrent)', run_all_services),
        '5': ('Check Environment', check_environment),
        '6': ('Exit', lambda: sys.exit(0)),
    }
    while True:
        print_header("Developer Task Runner")
        for k, (text, _) in menu.items():
            print(f"{k}. {text}")
        choice = input("Select an option: ").strip()
        action = menu.get(choice)
        if action:
            try:
                action[1]()
            except KeyboardInterrupt:
                print("\nOperation interrupted by user.")
        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    try:
        main()
    except (KeyboardInterrupt, SystemExit):
        print("\nTask runner stopped. Exiting.")
        sys.exit(0)
