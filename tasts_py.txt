import os
import subprocess
import platform
import threading
import sys
import json
import getpass
import shutil
import ctypes
import time
from datetime import datetime

# --- Configuration ---
ROOT_DIR = os.path.dirname(os.path.abspath(__file__))
SERVER_DIR = os.path.join(ROOT_DIR, 'server')
FRONTEND_DIR = ROOT_DIR

PYTHON_SERVER_SCRIPT_TXT = os.path.join(SERVER_DIR, 'server_py.txt')
PACKAGE_JSON = os.path.join(FRONTEND_DIR, 'package.json')
NODE_MODULES_LINK_PATH = os.path.join(FRONTEND_DIR, 'node_modules')

# --- Configuration for 'Tempo' user on Windows ---
TEMPO_PYTHON_EXECUTABLE = os.path.join('D:\\', 'installer_files', '.venv', 'Scripts', 'python.exe')
TEMPO_NODE_MODULES_TARGET = os.path.join('D:\\', 'installer_files', 'node_modules', 'openexpress', 'node_modules')
TEMPO_ENV_PATH = os.path.join('F:\\', 'Codebase', 'EnvSetup', 'cred', '.env', 'OpenExpress', '.env')
TEMPO_LOGS_DIR = os.path.join('F:\\', 'Codebase', 'EnvSetup', 'cred', '.env', 'OpenExpress', 'logs')


# --- Helper Functions ---

def log(msg):
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {msg}")

def is_user_tempo():
    try:
        return getpass.getuser().lower() == 'tempo' and platform.system() == 'Windows'
    except Exception:
        return False

def get_python_executable():
    if is_user_tempo():
        if os.path.exists(TEMPO_PYTHON_EXECUTABLE):
            log(f"Using custom Python executable for 'Tempo': {TEMPO_PYTHON_EXECUTABLE}")
            return TEMPO_PYTHON_EXECUTABLE
        else:
            log(f"Warning: Custom Python for 'Tempo' not found at {TEMPO_PYTHON_EXECUTABLE}. Falling back to default.")
    return sys.executable

PYTHON_EXECUTABLE = get_python_executable()

def is_admin():
    if platform.system() == "Windows":
        try:
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except Exception:
            return False
    # Assume admin/root for non-Windows systems for simplicity
    return os.geteuid() == 0 if hasattr(os, 'geteuid') else True


def setup_node_modules_junction():
    if not is_user_tempo():
        return True
    if not is_admin():
        log("‚ö†Ô∏è Symbolic link creation requires admin privileges on Windows. Please re-run this script as an administrator.")
        # It might still work if Developer Mode is enabled, so we don't exit.
        pass

    log("Setting up centralized node_modules link...")

    # --- Robust Removal with Native Commands ---
    if os.path.lexists(NODE_MODULES_LINK_PATH):
        log(f"Found existing item at '{NODE_MODULES_LINK_PATH}'. Attempting robust removal with native commands...")
        
        removal_command = f'rmdir /s /q "{NODE_MODULES_LINK_PATH}"'
        log(f"Executing removal command: {removal_command}")
        subprocess.run(removal_command, shell=True, check=False, capture_output=True)
        
        # --- Wait and Verify Removal ---
        max_wait_seconds = 5
        start_time = time.time()
        while os.path.lexists(NODE_MODULES_LINK_PATH) and time.time() - start_time < max_wait_seconds:
            log("Waiting for filesystem to release the path...")
            time.sleep(0.5)
        
        if os.path.lexists(NODE_MODULES_LINK_PATH):
            log(f"‚ùå Critical Error: Could not remove '{NODE_MODULES_LINK_PATH}' after {max_wait_seconds} seconds.")
            log("   - Please check if a file explorer or terminal has a lock on this directory.")
            return False
        else:
            log("‚úÖ Removal confirmed.")
    
    # --- Create Target Directory ---
    try:
        os.makedirs(TEMPO_NODE_MODULES_TARGET, exist_ok=True)
    except Exception as e:
        log(f"Failed to create target directory '{TEMPO_NODE_MODULES_TARGET}': {e}")
        return False

    # --- Retry Loop for Symbolic Link Creation ---
    log("Attempting to create a symbolic link (mklink /D) instead of a junction.")
    command = f'mklink /D "{NODE_MODULES_LINK_PATH}" "{TEMPO_NODE_MODULES_TARGET}"'
    max_retries = 3
    for attempt in range(max_retries):
        log(f"Executing (Attempt {attempt + 1}/{max_retries}): {command}")
        try:
            # Use subprocess.run for better error capture
            subprocess.run(command, shell=True, check=True, capture_output=True, text=True)
            log("‚úÖ Successfully created symbolic link for node_modules.")
            return True
        except subprocess.CalledProcessError as e:
            log(f"‚ö†Ô∏è Attempt {attempt + 1} failed.")
            log(f"   - Stderr: {e.stderr.strip()}")
            log(f"   - Stdout: {e.stdout.strip()}")
            if attempt < max_retries - 1:
                log("Retrying after a short delay...")
                time.sleep(1)
            else:
                log(f"‚ùå Error: Failed to create symbolic link after {max_retries} attempts.")
                log("   - This often requires running the script with Administrator privileges on Windows.")
                return False
    return False

def print_header(title: str):
    print("\n" + "="*50)
    print(f"üöÄ {title}")
    print("="*50)

def prepare_package_json():
    if os.path.exists(PACKAGE_JSON):
        return True
    log("package.json missing, creating default.")
    default_content = {
        "name": "openexpress-app",
        "version": "1.0.0",
        "main": "index.js",
        "type": "module",
        "scripts": {"dev": "vite", "build": "vite build"},
        "dependencies": {}
    }
    try:
        with open(PACKAGE_JSON, 'w', encoding='utf-8') as f:
            json.dump(default_content, f, indent=2)
        log("package.json created successfully.")
        return True
    except Exception as e:
        log(f"Failed to create package.json: {e}")
        return False

def run_pip_install(command, working_dir, name):
    log(f"{name}: Checking dependencies...")
    try:
        process = subprocess.run(
            command, cwd=working_dir, capture_output=True, text=True,
            shell=platform.system() == 'Windows', encoding='utf-8', errors='replace'
        )
        output = process.stdout + process.stderr
        lines = [line.strip() for line in output.splitlines() if line.strip()]
        
        is_already_satisfied = True
        has_lines = False
        for line in lines:
            has_lines = True
            if "Requirement already satisfied" not in line:
                is_already_satisfied = False
                break
        
        if has_lines and is_already_satisfied:
            log(f"{name}: ‚úÖ All dependencies are already installed.")
            return True
        else:
            log(f"{name}: Installing/updating dependencies...")
            print(output)
            if process.returncode != 0:
                log(f"{name}: ‚ùå Command failed with exit code {process.returncode}")
                return False
            log(f"{name}: ‚úÖ Dependencies installed successfully.")
            return True

    except Exception as e:
        log(f"{name}-ERR: {e}")
        return False

def install_backend_dependencies():
    print_header("Installing Backend (Python) Dependencies")
    run_pip_install([PYTHON_EXECUTABLE, '-m', 'pip', 'install', '-r', os.path.join(SERVER_DIR, 'requirements.txt')], SERVER_DIR, "pip-server")
    run_pip_install([PYTHON_EXECUTABLE, '-m', 'pip', 'install', '-r', os.path.join(ROOT_DIR, 'requirements.txt')], ROOT_DIR, "pip-vercel")

def install_frontend_dependencies():
    print_header("Installing Frontend (Node.js) Dependencies")
    if not prepare_package_json():
        log("Failed to prepare package.json, skipping npm install.")
        return

    if is_user_tempo():
        if not setup_node_modules_junction():
            log("‚ùå Failed to setup centralized node_modules. Aborting frontend dependency installation.")
            return
    elif os.path.lexists(NODE_MODULES_LINK_PATH):
        log(f"Removing existing node_modules from project directory: {NODE_MODULES_LINK_PATH}")
        try:
            shutil.rmtree(NODE_MODULES_LINK_PATH)
        except Exception as e:
            log(f"Failed to remove node_modules: {e}")
    
    log("Cleaning npm cache...")
    subprocess.run(['npm', 'cache', 'clean', '--force'], cwd=FRONTEND_DIR, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    
    log("Installing Node.js dependencies via npm (this may take a moment)...")
    try:
        use_shell = platform.system() == 'Windows'
        process = subprocess.Popen(
            ['npm', 'install'], cwd=FRONTEND_DIR, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
            text=True, shell=use_shell, encoding='utf-8', errors='replace'
        )
        
        output_lines = []
        for line in iter(process.stdout.readline, ''):
            line_strip = line.strip()
            if line_strip:
                print(f"[npm] {line_strip}")
                output_lines.append(line_strip)
        
        process.wait()
        
        if process.returncode != 0:
            log(f"‚ùå npm install failed with exit code {process.returncode}.")
            output_lower = ''.join(output_lines).lower()
            if "enoent" in output_lower and "package.json" in output_lower:
                log("Hint: npm reported it couldn't find 'package.json'. Please check file integrity.")
            if "e404" in output_lower:
                log("Hint: npm reported a '404 Not Found' error. A package may be misspelled or unavailable.")
            if "eresolve" in output_lower:
                 log("Hint: npm reported a dependency conflict ('ERESOLVE'). Try deleting 'package-lock.json' and running again.")
            return
    except Exception as e:
        log(f"An exception occurred during npm install: {e}")
        return

    log("‚úÖ npm install completed. Verifying key packages...")
    check_path = TEMPO_NODE_MODULES_TARGET if is_user_tempo() else NODE_MODULES_LINK_PATH
    key_packages = ['vite', 'react', 'react-dom', '@google/genai']
    missing_key_packages = []
    for pkg in key_packages:
        if not os.path.exists(os.path.join(check_path, pkg)):
            missing_key_packages.append(pkg)
            
    if missing_key_packages:
        log("‚ö†Ô∏è The following key packages seem to be missing after installation:")
        for pkg in missing_key_packages:
            print(f"  - {pkg}")
        log("This might indicate a problem with the npm installation or dependency resolution.")
    else:
        log("‚úÖ All key packages verified.")
    log("Frontend dependency installation complete.")


def install_all_dependencies():
    install_backend_dependencies()
    install_frontend_dependencies()

def run_command(command, working_dir, name, env=None):
    log(f"{name}: Starting command: {' '.join(command)}")
    process = subprocess.Popen(
        command, cwd=working_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        text=True, shell=True, env=env, encoding='utf-8', errors='replace'
    )
    def stream(pipe, prefix):
        for line in iter(pipe.readline, ''):
            if line.strip():
                print(f"[{prefix}] {line}", end='')
    t1 = threading.Thread(target=stream, args=(process.stdout, name))
    t2 = threading.Thread(target=stream, args=(process.stderr, f"{name}-ERR"))
    t1.start(); t2.start()
    process.wait(); t1.join(); t2.join()
    log(f"{name}: Process finished with exit code {process.returncode}")

def run_python_server():
    print_header("Running Python API & Auth Server")
    if not os.path.exists(PYTHON_SERVER_SCRIPT_TXT):
        log("Python server script missing")
        return
    run_command([PYTHON_EXECUTABLE, PYTHON_SERVER_SCRIPT_TXT], SERVER_DIR, "Python API")

def run_frontend_dev_server():
    print_header("Running Frontend Dev Server")
    
    if (is_user_tempo() and not os.path.exists(NODE_MODULES_LINK_PATH)) or \
       (not is_user_tempo() and not os.path.isdir(NODE_MODULES_LINK_PATH)):
        log("node_modules missing. Run 'Install Frontend Dependencies' first.")
        return
        
    vite_bin = os.path.join(NODE_MODULES_LINK_PATH, ".bin", "vite.cmd" if platform.system()=="Windows" else "vite")
    if not os.path.exists(vite_bin):
        log("Vite executable not found in node_modules. Run 'Install Frontend Dependencies' again.")
        return

    run_command(['npm', 'run', 'dev'], FRONTEND_DIR, "Frontend", env=os.environ.copy())

def run_all_services():
    print_header("Starting All Services")
    threads = [threading.Thread(target=run_python_server),
               threading.Thread(target=run_frontend_dev_server)]
    for t in threads: t.start()
    for t in threads: t.join()

def check_environment():
    print_header("Checking Environment")
    
    dotenv_path_project = os.path.join(ROOT_DIR, 'secrets', '.env')
    
    found_env_path = None
    if is_user_tempo() and os.path.exists(TEMPO_ENV_PATH):
        found_env_path = TEMPO_ENV_PATH
    elif os.path.exists(dotenv_path_project):
        found_env_path = dotenv_path_project

    checks = {
        "Python server script": os.path.exists(PYTHON_SERVER_SCRIPT_TXT),
        "package.json": os.path.exists(PACKAGE_JSON),
        "Server requirements.txt": os.path.exists(os.path.join(SERVER_DIR,'requirements.txt')),
        "Root requirements.txt": os.path.exists(os.path.join(ROOT_DIR,'requirements.txt')),
        ".env file": found_env_path is not None
    }
    for k,v in checks.items():
        print(f"- {k}: {'‚úÖ' if v else '‚ùå'}")
    
    if found_env_path:
        log(f"Found .env file at: {found_env_path}")
        
    if all(checks.values()):
        log("Environment OK")
    else:
        log("Some files are missing. Run dependency installation and check your .env file.")


def log_errors_only():
    print_header("Aggregating Error Logs")
    
    source_log_dir = TEMPO_LOGS_DIR if is_user_tempo() else os.path.join(ROOT_DIR, 'logs')
    source_log_file = os.path.join(source_log_dir, 'server.log')

    if not os.path.exists(source_log_file):
        log(f"Source log file not found: {source_log_file}")
        log("Please run the Python server to generate logs first.")
        return
    
    dest_error_file = os.path.join(source_log_dir, 'errors.log')
    if not os.path.exists(source_log_dir):
        os.makedirs(source_log_dir, exist_ok=True)
        
    error_lines = []
    try:
        with open(source_log_file, 'r', encoding='utf-8') as f:
            for line in f:
                if any(keyword in line for keyword in ['ERROR', 'Exception', 'Traceback', 'failed', 'Invalid', 'Expired']):
                    error_lines.append(line)
    except Exception as e:
        log(f"Error: Could not read source log file {source_log_file}: {e}")
        return
        
    try:
        with open(dest_error_file, 'w', encoding='utf-8') as f:
            if error_lines:
                f.write(f"# Error log generated at {datetime.now().isoformat()}\n" + "="*50 + "\n")
                f.writelines(error_lines)
                log(f"Successfully aggregated {len(error_lines)} error entries.")
            else:
                f.write(f"No new errors found in '{source_log_file}' as of {datetime.now().isoformat()}\n")
                log("No errors found in the log file.")
        log(f"Error log file is ready at: {dest_error_file}")
    except Exception as e:
        log(f"Error: Could not write to destination error file {dest_error_file}: {e}")

def main():
    menu = {
        '1': ('Install Backend (Python) Dependencies', install_backend_dependencies),
        '2': ('Install Frontend (Node) Dependencies', install_frontend_dependencies),
        '3': ('Install All Dependencies', install_all_dependencies),
        '4': ('Run Python API & Auth Server', run_python_server),
        '5': ('Run Frontend Dev Server', run_frontend_dev_server),
        '6': ('Run All Services', run_all_services),
        '7': ('Aggregate Error Logs', log_errors_only),
        '8': ('Check Environment', check_environment),
        '9': ('Exit', lambda: sys.exit(0))
    }
    while True:
        print_header("Developer Task Runner")
        for k, (txt, _) in sorted(menu.items()):
            print(f"{k}. {txt}")
        choice = input("Select option: ").strip()
        if choice in menu:
            menu[choice][1]()
        else:
            log("Invalid choice")

if __name__=="__main__":
    try:
        main()
    except (KeyboardInterrupt, SystemExit):
        log("Exiting...")
        sys.exit(0)