import os
import subprocess
import platform
import threading
import sys
import json
import getpass
import shutil
import ctypes
from datetime import datetime

# --- Configuration ---
ROOT_DIR = os.path.dirname(os.path.abspath(__file__))
SERVER_DIR = os.path.join(ROOT_DIR, 'server')
FRONTEND_DIR = ROOT_DIR

PYTHON_SERVER_SCRIPT_TXT = os.path.join(SERVER_DIR, 'server_py.txt')
PACKAGE_JSON = os.path.join(FRONTEND_DIR, 'package.json')

NODE_INSTALL_DIR_TEMPO = os.path.join('D:\\', 'installer_files', 'node_modules', 'openexpress')
NODE_MODULES_TARGET_TEMPO = os.path.join(NODE_INSTALL_DIR_TEMPO, 'node_modules')
NODE_MODULES_LINK_PATH = os.path.join(FRONTEND_DIR, 'node_modules')
ERROR_LOG_DIR_TEMPO = os.path.join('D:\\', 'installer_files', 'node_modules', 'openexpress', 'logs')

VITE_PLUGIN_REACT = '@vitejs/plugin-react'

# --- Helper Functions ---

def log(msg):
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {msg}")

def get_python_executable():
    try:
        if getpass.getuser().lower() == 'tempo' and platform.system() == 'Windows':
            custom_path = os.path.join('D:\\', 'installer_files', '.venv', 'Scripts', 'python.exe')
            if os.path.exists(custom_path):
                log(f"Using custom Python executable for 'Tempo': {custom_path}")
                return custom_path
    except Exception as e:
        log(f"Warning: {e}, falling back to default Python executable.")
    return sys.executable

PYTHON_EXECUTABLE = get_python_executable()

def is_user_tempo():
    try:
        return getpass.getuser().lower() == 'tempo' and platform.system() == 'Windows'
    except Exception:
        return False

def is_admin():
    if platform.system() == "Windows":
        try:
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except Exception:
            return False
    return True

def clear_node_modules_cache():
    """Removes local node_modules if exists and clears npm cache"""
    if os.path.lexists(NODE_MODULES_LINK_PATH):
        log(f"Removing existing node_modules from project directory: {NODE_MODULES_LINK_PATH}")
        try:
            if os.path.islink(NODE_MODULES_LINK_PATH):
                os.unlink(NODE_MODULES_LINK_PATH)
            else:
                shutil.rmtree(NODE_MODULES_LINK_PATH)
        except Exception as e:
            log(f"Failed to remove node_modules: {e}")
    
    log("Cleaning npm cache...")
    subprocess.run(['npm', 'cache', 'clean', '--force'], cwd=FRONTEND_DIR, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

def setup_node_modules_junction():
    if not is_user_tempo():
        return True
    if not is_admin():
        log("‚ö†Ô∏è Junction creation requires admin privileges on Windows. Please re-run as an administrator.")
        return False

    log("Setting up centralized node_modules junction...")

    # Forcefully remove any existing node_modules (folder or symlink) from the project directory.
    if os.path.lexists(NODE_MODULES_LINK_PATH):
        log(f"Found existing item at '{NODE_MODULES_LINK_PATH}'. Removing it.")
        try:
            if os.path.islink(NODE_MODULES_LINK_PATH):
                os.unlink(NODE_MODULES_LINK_PATH)
                log("Successfully removed existing symlink.")
            elif os.path.isdir(NODE_MODULES_LINK_PATH):
                shutil.rmtree(NODE_MODULES_LINK_PATH)
                log("Successfully removed existing directory.")
        except Exception as e:
            log(f"Error removing existing node_modules item: {e}")
            return False

    # Make sure the centralized target directory exists
    try:
        os.makedirs(NODE_MODULES_TARGET_TEMPO, exist_ok=True)
    except Exception as e:
        log(f"Failed to create target directory '{NODE_MODULES_TARGET_TEMPO}': {e}")
        return False

    # Create the junction link
    try:
        subprocess.check_call(
            f'mklink /J "{NODE_MODULES_LINK_PATH}" "{NODE_MODULES_TARGET_TEMPO}"',
            shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
        )
        log("Successfully created junction for node_modules.")
        return True
    except subprocess.CalledProcessError as e:
        log(f"Error: Failed to create junction. This can happen if the link path still exists or due to permissions issues.")
        log(f"Command failed with error: {e}")
        return False

def print_header(title: str):
    print("\n" + "="*50)
    print(f"üöÄ {title}")
    print("="*50)

def prepare_package_json():
    if os.path.exists(PACKAGE_JSON):
        return True
    log("package.json missing, creating default.")
    default_content = {
        "name": "openexpress-app",
        "version": "1.0.0",
        "main": "index.js",
        "type": "module",
        "scripts": {"dev": "vite", "build": "vite build"},
        "dependencies": {}
    }
    try:
        with open(PACKAGE_JSON, 'w', encoding='utf-8') as f:
            json.dump(default_content, f, indent=2)
        log("package.json created successfully.")
        return True
    except Exception as e:
        log(f"Failed to create package.json: {e}")
        return False

def run_command_filtered(command, working_dir, name):
    log(f"{name}: Running command: {' '.join(command)}")
    try:
        use_shell = platform.system() == 'Windows'
        process = subprocess.Popen(
            command, cwd=working_dir, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
            text=True, shell=use_shell, encoding='utf-8', errors='replace'
        )
        for line in iter(process.stdout.readline, ''):
            if line.strip():
                print(f"[{name}] {line}", end='')
        process.wait()
        if process.returncode != 0:
            log(f"{name}: Command failed with exit code {process.returncode}")
    except Exception as e:
        log(f"{name}-ERR: {e}")

def install_backend_dependencies():
    print_header("Installing Backend (Python) Dependencies")
    log("Installing Python dependencies for local server...")
    run_command_filtered([PYTHON_EXECUTABLE, '-m', 'pip', 'install', '-r', os.path.join(SERVER_DIR, 'requirements.txt')], SERVER_DIR, "pip-server")
    log("Installing Python dependencies for Vercel deployment...")
    run_command_filtered([PYTHON_EXECUTABLE, '-m', 'pip', 'install', '-r', os.path.join(ROOT_DIR, 'requirements.txt')], ROOT_DIR, "pip-vercel")

def install_frontend_dependencies():
    print_header("Installing Frontend (Node.js) Dependencies")
    if not prepare_package_json():
        log("Failed to prepare package.json, skipping npm install")
        return

    clear_node_modules_cache()
    if is_user_tempo() and not setup_node_modules_junction():
        log("Failed to setup centralized node_modules. Aborting frontend dependency installation.")
        return

    log("Installing Node.js dependencies via npm...")
    run_command_filtered(['npm', 'install'], FRONTEND_DIR, "npm")

    # Ensure @vitejs/plugin-react is installed
    plugin_path = os.path.join(NODE_MODULES_LINK_PATH, VITE_PLUGIN_REACT)
    if not os.path.exists(plugin_path):
        log(f"{VITE_PLUGIN_REACT} appears to be missing after install, attempting to install it directly...")
        run_command_filtered(['npm', 'install', VITE_PLUGIN_REACT, '--save-dev'], FRONTEND_DIR, "npm-vite-plugin")
    
    log("Frontend dependency installation complete.")

def install_all_dependencies():
    install_backend_dependencies()
    install_frontend_dependencies()

def run_command(command, working_dir, name, env=None):
    log(f"{name}: Starting command: {' '.join(command)}")
    process = subprocess.Popen(
        command, cwd=working_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        text=True, shell=True, env=env, encoding='utf-8', errors='replace'
    )
    def stream(pipe, prefix):
        for line in iter(pipe.readline, ''):
            if line.strip():
                print(f"[{prefix}] {line}", end='')
    t1 = threading.Thread(target=stream, args=(process.stdout, name))
    t2 = threading.Thread(target=stream, args=(process.stderr, f"{name}-ERR"))
    t1.start(); t2.start()
    process.wait(); t1.join(); t2.join()
    log(f"{name}: Process finished with exit code {process.returncode}")

def run_python_server():
    print_header("Running Python API & Auth Server")
    if not os.path.exists(PYTHON_SERVER_SCRIPT_TXT):
        log("Python server script missing")
        return
    run_command([PYTHON_EXECUTABLE, PYTHON_SERVER_SCRIPT_TXT], SERVER_DIR, "Python API")

def run_frontend_dev_server():
    print_header("Running Frontend Dev Server")
    if not os.path.isdir(NODE_MODULES_LINK_PATH):
        log("node_modules missing, run install_dependencies first")
        return

    vite_bin = os.path.join(NODE_MODULES_LINK_PATH, ".bin", "vite.cmd" if platform.system()=="Windows" else "vite")
    if not os.path.exists(vite_bin):
        log("Vite executable not found. Trying to install dependencies first...")
        install_frontend_dependencies()
        if not os.path.exists(vite_bin):
            log("Vite is still missing after install attempt. Cannot start server.")
            return

    run_command(['npm', 'run', 'dev'], FRONTEND_DIR, "Frontend", env=os.environ.copy())

def run_all_services():
    print_header("Starting All Services")
    # No need to run install again if user just wants to run
    threads = [threading.Thread(target=run_python_server),
               threading.Thread(target=run_frontend_dev_server)]
    for t in threads: t.start()
    for t in threads: t.join()

def check_environment():
    print_header("Checking Environment")
    checks = {
        "Python server script": os.path.exists(PYTHON_SERVER_SCRIPT_TXT),
        "package.json": os.path.exists(PACKAGE_JSON),
        "Server requirements.txt": os.path.exists(os.path.join(SERVER_DIR,'requirements.txt')),
        "Root requirements.txt": os.path.exists(os.path.join(ROOT_DIR,'requirements.txt')),
        ".env file": os.path.exists(os.path.join(ROOT_DIR,'secrets','.env'))
    }
    for k,v in checks.items():
        print(f"- {k}: {'‚úÖ' if v else '‚ùå'}")
    if all(checks.values()):
        log("Environment OK")
    else:
        log("Some files are missing. Run dependency installation and check your .env file.")

def log_errors_only():
    print_header("Aggregating Error Logs")
    
    # Determine source log file path by replicating server's logic
    log_dir_user = r'F:\Codebase\EnvSetup\cred\.env\OpenExpress\logs'
    log_dir_project = os.path.join(ROOT_DIR, 'logs')
    source_log_dir = log_dir_project

    if platform.system() == 'Windows' and os.path.exists(os.path.dirname(log_dir_user)):
        source_log_dir = log_dir_user

    source_log_file = os.path.join(source_log_dir, 'server.log')

    if not os.path.exists(source_log_file):
        log(f"Source log file not found: {source_log_file}")
        log("Please run the Python server to generate logs first.")
        return

    # Determine destination error log file path
    dest_log_dir = log_dir_project  # Default for non-Tempo users
    if is_user_tempo():
        dest_log_dir = ERROR_LOG_DIR_TEMPO
    
    try:
        os.makedirs(dest_log_dir, exist_ok=True)
    except Exception as e:
        log(f"Error: Could not create destination directory {dest_log_dir}: {e}")
        return
        
    dest_error_file = os.path.join(dest_log_dir, 'errors.log')

    # Read source and filter for error-related lines
    error_lines = []
    try:
        with open(source_log_file, 'r', encoding='utf-8') as f:
            for line in f:
                # Keywords to identify error lines
                if any(keyword in line for keyword in ['ERROR', 'Exception', 'Traceback', 'failed', 'Invalid', 'Expired']):
                    error_lines.append(line)
    except Exception as e:
        log(f"Error: Could not read source log file {source_log_file}: {e}")
        return
        
    # Write to destination file
    try:
        with open(dest_error_file, 'w', encoding='utf-8') as f:
            if error_lines:
                f.write(f"# Error log generated at {datetime.now().isoformat()}\n")
                f.write("="*50 + "\n")
                f.writelines(error_lines)
                log(f"Successfully aggregated {len(error_lines)} error entries.")
            else:
                f.write(f"No new errors found in '{source_log_file}' as of {datetime.now().isoformat()}\n")
                log("No errors found in the log file.")
        log(f"Error log file is ready at: {dest_error_file}")
    except Exception as e:
        log(f"Error: Could not write to destination error file {dest_error_file}: {e}")

def main():
    menu = {
        '1': ('Install Backend (Python) Dependencies', install_backend_dependencies),
        '2': ('Install Frontend (Node) Dependencies', install_frontend_dependencies),
        '3': ('Install All Dependencies', install_all_dependencies),
        '4': ('Run Python API & Auth Server', run_python_server),
        '5': ('Run Frontend Dev Server', run_frontend_dev_server),
        '6': ('Run All Services', run_all_services),
        '7': ('Aggregate Error Logs', log_errors_only),
        '8': ('Check Environment', check_environment),
        '9': ('Exit', lambda: sys.exit(0))
    }
    while True:
        print_header("Developer Task Runner")
        for k, (txt, _) in sorted(menu.items()):
            print(f"{k}. {txt}")
        choice = input("Select option: ").strip()
        if choice in menu:
            menu[choice][1]()
        else:
            log("Invalid choice")

if __name__=="__main__":
    try:
        main()
    except (KeyboardInterrupt, SystemExit):
        log("Exiting...")
        sys.exit(0)
