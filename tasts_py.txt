import os
import subprocess
import platform
import threading
import sys
import json
import getpass
import shutil
import ctypes
from datetime import datetime

# --- Configuration ---
ROOT_DIR = os.path.dirname(os.path.abspath(__file__))
SERVER_DIR = os.path.join(ROOT_DIR, 'server')
FRONTEND_DIR = ROOT_DIR

PYTHON_SERVER_SCRIPT_TXT = os.path.join(SERVER_DIR, 'server_py.txt')
PACKAGE_JSON = os.path.join(FRONTEND_DIR, 'package.json')
NODE_MODULES_LINK_PATH = os.path.join(FRONTEND_DIR, 'node_modules')
SYMLINK_MANAGER_SCRIPT = os.path.join(ROOT_DIR, 'symlink_manager_py.txt')


# --- Configuration for 'Tempo' user on Windows ---
TEMPO_PYTHON_EXECUTABLE = os.path.join('D:\\', 'installer_files', '.venv', 'Scripts', 'python.exe')
TEMPO_ENV_PATH = os.path.join('F:\\', 'Codebase', 'EnvSetup', 'cred', '.env', 'OpenExpress', '.env')
TEMPO_LOGS_DIR = os.path.join('F:\\', 'Codebase', 'EnvSetup', 'cred', '.env', 'OpenExpress', 'logs')
TEMPO_NODE_MODULES_TARGET = os.path.join('D:\\', 'installer_files', 'node_modules', 'OpenExpress', 'node_modules')


# --- Helper Functions ---

def log(msg):
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {msg}")

def is_user_tempo():
    try:
        return getpass.getuser().lower() == 'tempo' and platform.system() == 'Windows'
    except Exception:
        return False

def get_python_executable():
    if is_user_tempo():
        if os.path.exists(TEMPO_PYTHON_EXECUTABLE):
            log(f"Using custom Python executable for 'Tempo': {TEMPO_PYTHON_EXECUTABLE}")
            return TEMPO_PYTHON_EXECUTABLE
        else:
            log(f"Warning: Custom Python for 'Tempo' not found at {TEMPO_PYTHON_EXECUTABLE}. Falling back to default.")
    return sys.executable

PYTHON_EXECUTABLE = get_python_executable()

def is_admin():
    if platform.system() == "Windows":
        try:
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except Exception:
            return False
    return os.geteuid() == 0 if hasattr(os, 'geteuid') else True


def print_header(title: str):
    print("\n" + "="*50)
    print(f"üöÄ {title}")
    print("="*50)

def prepare_package_json():
    if os.path.exists(PACKAGE_JSON):
        return True
    log("package.json missing, creating default.")
    default_content = {
        "name": "openexpress-app",
        "version": "1.0.0",
        "main": "index.js",
        "type": "module",
        "scripts": {"dev": "vite", "build": "vite build"},
        "dependencies": {}
    }
    try:
        with open(PACKAGE_JSON, 'w', encoding='utf-8') as f:
            json.dump(default_content, f, indent=2)
        log("package.json created successfully.")
        return True
    except Exception as e:
        log(f"Failed to create package.json: {e}")
        return False

# --- New Management & QA Functions ---
def check_vercel_compatibility():
    print_header("Checking Vercel Compatibility")
    log("This test checks for files and configurations required for a successful Vercel deployment.")
    
    checks = {
        "vercel.json exists": os.path.exists(os.path.join(ROOT_DIR, 'vercel.json')),
        "api/index_py.txt exists": os.path.exists(os.path.join(ROOT_DIR, 'api', 'index_py.txt')),
        "Root requirements.txt exists": os.path.exists(os.path.join(ROOT_DIR, 'requirements.txt')),
        "'vercel-build' script in package.json": False,
    }
    
    if os.path.exists(PACKAGE_JSON):
        try:
            with open(PACKAGE_JSON, 'r', encoding='utf-8') as f:
                data = json.load(f)
                if data.get('scripts', {}).get('vercel-build'):
                    checks["'vercel-build' script in package.json"] = True
        except Exception as e:
            log(f"Could not read package.json: {e}")
            
    all_ok = True
    for check, result in checks.items():
        if result:
            log(f"  ‚úÖ {check}")
        else:
            log(f"  ‚ùå {check}")
            all_ok = False
            
    if all_ok:
        log("\n‚úÖ Vercel configuration appears to be correct.")
    else:
        log("\n‚ö†Ô∏è Some Vercel compatibility checks failed. Please review the items above.")

def report_new_error():
    print_header("Report a New Error")
    
    machine_types = ['win', 'vercel', 'linux', 'aistudio']
    log("Select the machine type where the error occurred:")
    for i, mtype in enumerate(machine_types, 1):
        print(f"  {i}. {mtype}")
    
    choice = input("Enter number: ").strip()
    try:
        machine_type = machine_types[int(choice) - 1]
    except (ValueError, IndexError):
        log("‚ùå Invalid selection.")
        return
        
    error_id = input("Enter a short, file-safe ID for the error (e.g., 'symlink_creation_failed'): ").strip()
    if not error_id or any(c in error_id for c in ' /\\:*?"<>|'):
        log("‚ùå Invalid error ID. It cannot be empty or contain special characters.")
        return
        
    error_dir = os.path.join(ROOT_DIR, 'known_errors', machine_type)
    os.makedirs(error_dir, exist_ok=True)
    
    error_file_path = os.path.join(error_dir, f"{error_id}.md")
    
    if os.path.exists(error_file_path):
        log(f"‚ö†Ô∏è Error report '{error_file_path}' already exists. Aborting.")
        return
        
    template = f"""
# Error Report: {error_id}

- **Machine Type:** {machine_type}
- **Date Reported:** {datetime.now().isoformat()}

## Description
(Provide a detailed description of the error. What were you trying to do?)


## Steps to Reproduce
1. ...
2. ...
3. ...


## Logs / Screenshots
(Paste any relevant logs or add screenshots here)


## Associated Patch
(Link to the patch file if one is created, e.g., `patch/{machine_type}/{error_id}/fix.js`)
"""
    try:
        with open(error_file_path, 'w', encoding='utf-8') as f:
            f.write(template.strip())
        log(f"‚úÖ Successfully created new error report at: {error_file_path}")
    except Exception as e:
        log(f"‚ùå Failed to create error report file: {e}")

def create_patch():
    print_header("Create a New Patch")
    
    known_errors_dir = os.path.join(ROOT_DIR, 'known_errors')
    error_reports = []
    if os.path.isdir(known_errors_dir):
        for root, _, files in os.walk(known_errors_dir):
            for file in files:
                if file.endswith('.md'):
                    machine_type = os.path.basename(os.path.dirname(root))
                    error_id = file.replace('.md', '')
                    error_reports.append({'machine': machine_type, 'id': error_id})

    if not error_reports:
        log("No existing error reports found in 'known_errors/'. Please report an error first.")
        return

    log("Select the error this patch is for:")
    for i, report in enumerate(error_reports, 1):
        print(f"  {i}. [{report['machine']}] {report['id']}")

    choice = input("Enter number: ").strip()
    try:
        selected_report = error_reports[int(choice) - 1]
    except (ValueError, IndexError):
        log("‚ùå Invalid selection.")
        return
        
    patch_filename = input("Enter the name for the patch file (e.g., 'fix_symlink.js' or 'update_config_py.txt'): ").strip()
    if not patch_filename or any(c in patch_filename for c in '/\\:*?"<>|'):
        log("‚ùå Invalid filename.")
        return

    patch_dir = os.path.join(ROOT_DIR, 'patch', selected_report['machine'], selected_report['id'])
    os.makedirs(patch_dir, exist_ok=True)
    
    patch_file_path = os.path.join(patch_dir, patch_filename)
    
    if os.path.exists(patch_file_path):
        log(f"‚ö†Ô∏è Patch file '{patch_file_path}' already exists. Aborting.")
        return
        
    try:
        with open(patch_file_path, 'w', encoding='utf-8') as f:
            f.write(f"# Patch for {selected_report['machine']}/{selected_report['id']}\n")
            f.write(f"# Created at {datetime.now().isoformat()}\n\n")
        log(f"‚úÖ Successfully created empty patch file at: {patch_file_path}")
        log("   Don't forget to update the corresponding error report with the patch link.")
    except Exception as e:
        log(f"‚ùå Failed to create patch file: {e}")

def lint_file_formats():
    print_header("Linting Project File Formats")
    log("Checking for .py or .ipynb files that should use a .txt extension...")
    
    violations = []
    search_dirs = [os.path.join(ROOT_DIR, 'server'), os.path.join(ROOT_DIR, 'api')]
    
    for directory in search_dirs:
        if not os.path.isdir(directory):
            continue
        for root, _, files in os.walk(directory):
            for file in files:
                if file.endswith('.py') or file.endswith('.ipynb'):
                    if '.venv' in root or 'venv' in root:
                        continue
                    violations.append(os.path.join(root, file))
                    
    if not violations:
        log("‚úÖ No violations found. All Python/Jupyter files seem to be correctly named with .txt extensions.")
    else:
        log(f"‚ö†Ô∏è Found {len(violations)} violation(s):")
        for v in violations:
            log(f"  - File '{os.path.relpath(v, ROOT_DIR)}' should be renamed with a '.txt' suffix (e.g., _py.txt or _ipynb.txt).")

# --- Core Execution Functions ---

def run_pip_install(command, working_dir, name):
    log(f"{name}: Checking dependencies...")
    try:
        process = subprocess.run(
            command, cwd=working_dir, capture_output=True, text=True,
            shell=platform.system() == 'Windows', encoding='utf-8', errors='replace'
        )
        output = process.stdout + process.stderr
        lines = [line.strip() for line in output.splitlines() if line.strip()]
        
        is_already_satisfied = True
        has_lines = False
        for line in lines:
            has_lines = True
            if "Requirement already satisfied" not in line:
                is_already_satisfied = False
                break
        
        if has_lines and is_already_satisfied:
            log(f"{name}: ‚úÖ All dependencies are already installed.")
            return True
        else:
            log(f"{name}: Installing/updating dependencies...")
            print(output)
            if process.returncode != 0:
                log(f"{name}: ‚ùå Command failed with exit code {process.returncode}")
                return False
            log(f"{name}: ‚úÖ Dependencies installed successfully.")
            return True

    except Exception as e:
        log(f"{name}-ERR: {e}")
        return False

def install_backend_dependencies():
    print_header("Installing Backend (Python) Dependencies")
    run_pip_install([PYTHON_EXECUTABLE, '-m', 'pip', 'install', '-r', os.path.join(SERVER_DIR, 'requirements.txt')], SERVER_DIR, "pip-server")
    run_pip_install([PYTHON_EXECUTABLE, '-m', 'pip', 'install', '-r', os.path.join(ROOT_DIR, 'requirements.txt')], ROOT_DIR, "pip-vercel")

def install_frontend_dependencies():
    print_header("Installing Frontend (Node.js) Dependencies")
    if not prepare_package_json():
        log("Failed to prepare package.json, skipping npm install.")
        return

    if is_user_tempo():
        log("User 'Tempo' on Windows detected. Setting up symlink for node_modules.")
        if not is_admin():
            log("‚ö†Ô∏è Warning: Not running as Administrator. Symlink creation might fail.")
            log("   Please re-run this script in a terminal with Administrator privileges.")
        
        if not os.path.exists(SYMLINK_MANAGER_SCRIPT):
             log(f"‚ùå Symlink manager script not found at '{SYMLINK_MANAGER_SCRIPT}'. Aborting.")
             return
             
        try:
            log(f"Executing symlink manager: {PYTHON_EXECUTABLE} {SYMLINK_MANAGER_SCRIPT} ...")
            # Ensure paths are passed correctly for the subprocess
            subprocess.run(
                [PYTHON_EXECUTABLE, SYMLINK_MANAGER_SCRIPT, TEMPO_NODE_MODULES_TARGET, NODE_MODULES_LINK_PATH],
                check=True
            )
            log("Symlink setup complete.")
        except subprocess.CalledProcessError as e:
            log(f"‚ùå Symlink manager script failed with exit code {e.returncode}. Cannot proceed with npm install.")
            return
        except Exception as e:
            log(f"‚ùå An unexpected error occurred while running symlink manager: {e}")
            return
    else:
        log("Standard user detected. Installing node_modules locally.")
        # Clean up any existing symlink in case user switched from 'Tempo'
        if os.path.islink(NODE_MODULES_LINK_PATH):
            log(f"Removing existing symlink at {NODE_MODULES_LINK_PATH}")
            os.remove(NODE_MODULES_LINK_PATH)

    log("Cleaning npm cache...")
    subprocess.run(['npm', 'cache', 'clean', '--force'], cwd=FRONTEND_DIR, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    
    log("Installing Node.js dependencies via npm (this may take a moment)...")
    try:
        use_shell = platform.system() == 'Windows'
        process = subprocess.Popen(
            ['npm', 'install'], cwd=FRONTEND_DIR, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
            text=True, shell=use_shell, encoding='utf-8', errors='replace'
        )
        
        output_lines = []
        for line in iter(process.stdout.readline, ''):
            line_strip = line.strip()
            if line_strip:
                print(f"[npm] {line_strip}")
                output_lines.append(line_strip)
        
        process.wait()
        
        if process.returncode != 0:
            log(f"‚ùå npm install failed with exit code {process.returncode}.")
            output_lower = ''.join(output_lines).lower()
            if "enoent" in output_lower and "package.json" in output_lower:
                log("Hint: npm reported it couldn't find 'package.json'. Please check file integrity.")
            if "e404" in output_lower:
                log("Hint: npm reported a '404 Not Found' error. A package may be misspelled or unavailable.")
            if "eresolve" in output_lower:
                 log("Hint: npm reported a dependency conflict ('ERESOLVE'). Try deleting 'package-lock.json' and running again.")
            return
    except Exception as e:
        log(f"An exception occurred during npm install: {e}")
        return

    log("‚úÖ npm install completed. Verifying key packages...")
    check_path = NODE_MODULES_LINK_PATH
    key_packages = ['vite', 'react', 'react-dom', '@google/genai']
    missing_key_packages = []
    for pkg in key_packages:
        if not os.path.exists(os.path.join(check_path, pkg)):
            missing_key_packages.append(pkg)
            
    if missing_key_packages:
        log("‚ö†Ô∏è The following key packages seem to be missing after installation:")
        for pkg in missing_key_packages:
            print(f"  - {pkg}")
        log("This might indicate a problem with the npm installation or dependency resolution.")
    else:
        log("‚úÖ All key packages verified.")
    log("Frontend dependency installation complete.")


def install_all_dependencies():
    install_backend_dependencies()
    install_frontend_dependencies()

def run_command(command, working_dir, name, env=None):
    log(f"{name}: Starting command: {' '.join(command)}")
    process = subprocess.Popen(
        command, cwd=working_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        text=True, shell=True, env=env, encoding='utf-8', errors='replace'
    )
    def stream(pipe, prefix):
        for line in iter(pipe.readline, ''):
            if line.strip():
                print(f"[{prefix}] {line}", end='')
    t1 = threading.Thread(target=stream, args=(process.stdout, name))
    t2 = threading.Thread(target=stream, args=(process.stderr, f"{name}-ERR"))
    t1.start(); t2.start()
    process.wait(); t1.join(); t2.join()
    log(f"{name}: Process finished with exit code {process.returncode}")

def run_python_server():
    print_header("Running Python API & Auth Server")
    if not os.path.exists(PYTHON_SERVER_SCRIPT_TXT):
        log("Python server script missing")
        return
    run_command([PYTHON_EXECUTABLE, PYTHON_SERVER_SCRIPT_TXT], SERVER_DIR, "Python API")

def run_frontend_dev_server():
    print_header("Running Frontend Dev Server")
    
    if not os.path.isdir(NODE_MODULES_LINK_PATH):
        log("node_modules missing. Run 'Install Frontend Dependencies' first.")
        return
        
    vite_bin = os.path.join(NODE_MODULES_LINK_PATH, ".bin", "vite.cmd" if platform.system()=="Windows" else "vite")
    if not os.path.exists(vite_bin):
        log("Vite executable not found in node_modules. Run 'Install Frontend Dependencies' again.")
        return

    run_command(['npm', 'run', 'dev'], FRONTEND_DIR, "Frontend", env=os.environ.copy())

def run_all_services():
    print_header("Starting All Services")
    threads = [threading.Thread(target=run_python_server),
               threading.Thread(target=run_frontend_dev_server)]
    for t in threads: t.start()
    for t in threads: t.join()

def check_environment():
    print_header("Checking Environment")
    
    # Standard path for secrets
    project_dotenv_path = os.path.join(ROOT_DIR, 'secrets', '.env')
    
    found_env_path = None
    if is_user_tempo() and os.path.exists(TEMPO_ENV_PATH):
        # User-specific path takes precedence
        found_env_path = TEMPO_ENV_PATH
    elif os.path.exists(project_dotenv_path):
        found_env_path = project_dotenv_path

    checks = {
        "Python server script": os.path.exists(PYTHON_SERVER_SCRIPT_TXT),
        "package.json": os.path.exists(PACKAGE_JSON),
        "Server requirements.txt": os.path.exists(os.path.join(SERVER_DIR,'requirements.txt')),
        "Root requirements.txt": os.path.exists(os.path.join(ROOT_DIR,'requirements.txt')),
        ".env file in secrets/ or custom path": found_env_path is not None
    }
    
    for k,v in checks.items():
        print(f"- {k}: {'‚úÖ' if v else '‚ùå'}")
    
    if found_env_path:
        log(f"Found .env file at: {found_env_path}")
    else:
        log("Warning: .env file not found in secrets/ or custom user path.")
        
    if all(checks.values()):
        log("\n‚úÖ Environment checks passed.")
    else:
        log("\n‚ö†Ô∏è Some environment checks failed. Please review file structure and run dependency installation.")


def log_errors_only():
    print_header("Aggregating Error Logs")
    
    source_log_dir = TEMPO_LOGS_DIR if is_user_tempo() else os.path.join(ROOT_DIR, 'logs')
    source_log_file = os.path.join(source_log_dir, 'server.log')

    if not os.path.exists(source_log_file):
        log(f"Source log file not found: {source_log_file}")
        log("Please run the Python server to generate logs first.")
        return
    
    dest_error_file = os.path.join(source_log_dir, 'errors.log')
    if not os.path.exists(source_log_dir):
        os.makedirs(source_log_dir, exist_ok=True)
        
    error_lines = []
    try:
        with open(source_log_file, 'r', encoding='utf-8') as f:
            for line in f:
                if any(keyword in line for keyword in ['ERROR', 'Exception', 'Traceback', 'failed', 'Invalid', 'Expired']):
                    error_lines.append(line)
    except Exception as e:
        log(f"Error: Could not read source log file {source_log_file}: {e}")
        return
        
    try:
        with open(dest_error_file, 'w', encoding='utf-8') as f:
            if error_lines:
                f.write(f"# Error log generated at {datetime.now().isoformat()}\n" + "="*50 + "\n")
                f.writelines(error_lines)
                log(f"Successfully aggregated {len(error_lines)} error entries.")
            else:
                f.write(f"No new errors found in '{source_log_file}' as of {datetime.now().isoformat()}\n")
                log("No errors found in the log file.")
        log(f"Error log file is ready at: {dest_error_file}")
    except Exception as e:
        log(f"Error: Could not write to destination error file {dest_error_file}: {e}")

def main():
    menu = {
        '1': ('Install All Dependencies', install_all_dependencies),
        '2': ('Install Backend (Python) Only', install_backend_dependencies),
        '3': ('Install Frontend (Node) Only', install_frontend_dependencies),
        '4': ('--------------------', None),
        '5': ('Run All Services', run_all_services),
        '6': ('Run Python Server Only', run_python_server),
        '7': ('Run Frontend Server Only', run_frontend_dev_server),
        '8': ('--------------------', None),
        '9': ('Check Environment', check_environment),
        '10': ('Check Vercel Compatibility', check_vercel_compatibility),
        '11': ('Lint File Formats', lint_file_formats),
        '12': ('--------------------', None),
        '13': ('Aggregate Error Logs', log_errors_only),
        '14': ('Report a New Error', report_new_error),
        '15': ('Create a Patch for an Error', create_patch),
        '16': ('--------------------', None),
        '17': ('Exit', lambda: sys.exit(0))
    }

    while True:
        print_header("Developer Task Runner")
        for k, (txt, func) in sorted(menu.items(), key=lambda item: int(item[0])):
            if func is None:
                print(f"   {txt}")
            else:
                print(f"{k.rjust(2)}. {txt}")
        
        choice = input("Select option: ").strip()
        
        if choice in menu:
            action = menu[choice][1]
            if action:
                action()
            else: # It's a separator
                continue
        else:
            log("Invalid choice")

if __name__=="__main__":
    try:
        main()
    except (KeyboardInterrupt, SystemExit):
        log("\nExiting...")
        sys.exit(0)
    except EOFError:
        log("\nExiting due to non-interactive mode or end of input.")
        sys.exit(0)