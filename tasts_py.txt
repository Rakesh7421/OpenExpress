import os
import subprocess
import platform
import threading
import sys
import json
import getpass

# --- Configuration ---
ROOT_DIR = os.path.dirname(os.path.abspath(__file__))
SERVER_DIR = os.path.join(ROOT_DIR, 'server')
FRONTEND_DIR = ROOT_DIR

PYTHON_SERVER_SCRIPT_TXT = os.path.join(SERVER_DIR, 'server_py.txt')
PACKAGE_JSON = os.path.join(ROOT_DIR, 'package.json')

# Configuration for 'Tempo' user on Windows
NODE_INSTALL_DIR_TEMPO = os.path.join('D:\\', 'installer_files', 'node_modules', 'openexpress')
NODE_MODULES_TARGET_TEMPO = os.path.join(NODE_INSTALL_DIR_TEMPO, 'node_modules')
NODE_MODULES_LINK_PATH = os.path.join(FRONTEND_DIR, 'node_modules')


# --- Helper Functions ---

def get_python_executable():
    """Returns the path to the python executable, with special handling for user 'Tempo'."""
    try:
        if getpass.getuser().lower() == 'tempo' and platform.system() == 'Windows':
            custom_path = os.path.join('D:\\', 'installer_files', '.venv', 'Scripts', 'python.exe')
            if os.path.exists(custom_path):
                print(f"Info: Using custom Python executable for user 'Tempo': {custom_path}")
                return custom_path
            else:
                print(f"Warning: Custom Python path for 'Tempo' not found at '{custom_path}'. Falling back to default.")
    except Exception as e:
        print(f"Warning: Could not get username or check custom path. Reason: {e}. Falling back to default.")
    
    return sys.executable

PYTHON_EXECUTABLE = get_python_executable()

def is_user_tempo():
    """Checks if the current user is 'Tempo' on Windows."""
    try:
        return getpass.getuser().lower() == 'tempo' and platform.system() == 'Windows'
    except Exception:
        return False

def setup_node_modules_junction():
    """For user 'Tempo', creates a directory junction for node_modules to a dedicated folder."""
    if not is_user_tempo():
        return True # Not applicable, so we consider it a success.

    print("Info: User 'Tempo' detected on Windows. Setting up centralized node_modules.")
    print(f"  Target: {NODE_MODULES_TARGET_TEMPO}")
    print(f"  Link:   {NODE_MODULES_LINK_PATH}")

    # Check if the link path already exists
    if os.path.lexists(NODE_MODULES_LINK_PATH):
        if os.path.isdir(NODE_MODULES_LINK_PATH) and not os.path.islink(NODE_MODULES_LINK_PATH):
            print("Info: 'node_modules' directory exists. Assuming it's the correct junction/link.")
            return True
        elif os.path.islink(NODE_MODULES_LINK_PATH):
            print("Info: Symlink/junction already exists. No action needed.")
            return True
        else:
            print("Error: A file named 'node_modules' already exists and is not a directory/junction.")
            print("Please remove it manually to proceed with centralized installation.")
            return False
            
    # Ensure the target directory exists
    try:
        os.makedirs(NODE_MODULES_TARGET_TEMPO, exist_ok=True)
    except OSError as e:
        print(f"Error: Could not create target directory '{NODE_MODULES_TARGET_TEMPO}'. Reason: {e}")
        return False
        
    # Create the junction using mklink, which is ideal for directories on Windows
    try:
        subprocess.check_call(f'mklink /J "{NODE_MODULES_LINK_PATH}" "{NODE_MODULES_TARGET_TEMPO}"', shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        print("Successfully created junction for node_modules.")
        return True
    except subprocess.CalledProcessError as e:
        print(f"Error: Could not create junction for node_modules. 'mklink' command failed. Reason: {e}")
        print("This is a standard Windows command. Please check your system configuration or permissions.")
        return False
    except Exception as e:
        print(f"Error: An unexpected error occurred while creating the junction: {e}")
        return False

def print_header(title: str):
    """Prints a styled header."""
    print("\n" + "=" * 50)
    print(f"üöÄ {title}")
    print("=" * 50)

def prepare_package_json():
    """Ensures package.json exists, creating it from a default structure if needed."""
    if os.path.exists(PACKAGE_JSON):
        return True

    print(f"Info: '{os.path.basename(PACKAGE_JSON)}' not found. Creating a default package.json...")
    
    default_package_content = {
      "name": "openexpress-app",
      "version": "1.0.0",
      "description": "A UI for a design and content creation app.",
      "main": "index.js",
      "type": "module",
      "scripts": {
        "dev": "vite",
        "build": "vite build",
        "vercel-build": "cp api/index_py.txt api/index.py"
      },
      "author": "",
      "license": "ISC",
       "dependencies": {}
    }

    try:
        with open(PACKAGE_JSON, 'w', encoding='utf-8') as f:
            json.dump(default_package_content, f, indent=2)
        print(f"Successfully created '{os.path.relpath(PACKAGE_JSON, ROOT_DIR)}'.")
        return True
    except Exception as e:
        print(f"Error: Could not create package.json. Reason: {e}")
        return False


def run_command(command, working_dir, name, env=None):
    """Runs a command in a subprocess and streams its output."""
    print(f"[{name}] Starting process: {' '.join(command)}")
    try:
        use_shell = platform.system() == 'Windows'
        process = subprocess.Popen(
            command, cwd=working_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            text=True, encoding='utf-8', errors='replace', env=env, shell=use_shell
        )
        def stream_output(pipe, prefix):
            if pipe:
                for line in iter(pipe.readline, ''):
                    print(f"{prefix} {line}", end='')
        
        stdout_thread = threading.Thread(target=stream_output, args=(process.stdout, f"[{name}]"))
        stderr_thread = threading.Thread(target=stream_output, args=(process.stderr, f"[{name}-ERR]"))
        stdout_thread.start()
        stderr_thread.start()
        process.wait()
        stdout_thread.join()
        stderr_thread.join()
        print(f"[{name}] Process finished with exit code {process.returncode}.")
    except FileNotFoundError:
        print(f"[{name}-ERR] Command not found: {command[0]}. Is it installed and in your PATH?")
    except Exception as e:
        print(f"[{name}-ERR] An error occurred: {e}")

# --- Task Functions ---

def install_dependencies():
    """Installs both Python and Node.js dependencies."""
    print_header("Installing Dependencies")
    
    print("\n--- Installing Python dependencies ---")
    run_command([PYTHON_EXECUTABLE, '-m', 'pip', 'install', '-r', 'requirements.txt'], SERVER_DIR, "pip-server")
    run_command([PYTHON_EXECUTABLE, '-m', 'pip', 'install', '-r', 'requirements.txt'], ROOT_DIR, "pip-vercel")
    
    print("\n--- Installing Node.js dependencies ---")
    if not prepare_package_json():
        print("[npm-ERR] Could not prepare package.json for Node.js. Skipping npm install.")
        return
    
    if is_user_tempo():
        if not setup_node_modules_junction():
            print("[npm-ERR] Failed to set up centralized node_modules. Aborting npm install.")
            return

    # Run npm install normally. If junction exists, it will install to the target dir.
    run_command(['npm', 'install'], FRONTEND_DIR, "npm")

def run_python_server():
    """Runs the Python/Flask API & Auth server."""
    print_header("Running Python API & Auth Server")
    if not os.path.exists(PYTHON_SERVER_SCRIPT_TXT):
        print(f"[Python API-ERR] Source file not found: {os.path.relpath(PYTHON_SERVER_SCRIPT_TXT, ROOT_DIR)}")
        return
    
    run_command([PYTHON_EXECUTABLE, PYTHON_SERVER_SCRIPT_TXT], SERVER_DIR, "Python API")

def run_frontend_dev_server():
    """Runs the frontend development server (Vite)."""
    print_header("Running Frontend Dev Server")
    if not os.path.isdir(NODE_MODULES_LINK_PATH):
        print("[Frontend-ERR] 'node_modules' directory not found. Cannot start. Try running 'Install Dependencies' first.")
        return
    
    run_command(['npm', 'run', 'dev'], FRONTEND_DIR, "Frontend")


def run_all_services():
    """Runs all services concurrently in separate threads."""
    print_header("Starting All Services")

    if not os.path.isdir(NODE_MODULES_LINK_PATH):
        print(f"\nInfo: 'node_modules' directory not found. Running dependency installation first.")
        install_dependencies()
        if not os.path.isdir(NODE_MODULES_LINK_PATH):
            print("\nError: Dependency installation failed. Cannot start services.")
            return

    if not os.path.exists(PYTHON_SERVER_SCRIPT_TXT):
         print("\nRequired Python server script is missing.")
         return

    threads = [
        threading.Thread(target=run_python_server),
        threading.Thread(target=run_frontend_dev_server)
    ]
    
    for t in threads:
        t.start()
    
    try:
        for t in threads:
            t.join()
    except KeyboardInterrupt:
        print("\nCaught KeyboardInterrupt, stopping services...")

def check_environment():
    """Checks for necessary files and configurations."""
    print_header("Checking Environment")
    
    pkg_json_ok = prepare_package_json()

    checks = {
        "Python Server Source (server_py.txt)": os.path.exists(PYTHON_SERVER_SCRIPT_TXT),
        "package.json in root": pkg_json_ok,
        "Python requirements.txt (server)": os.path.exists(os.path.join(SERVER_DIR, 'requirements.txt')),
        "Python requirements.txt (vercel)": os.path.exists(os.path.join(ROOT_DIR, 'requirements.txt')),
        "Secrets .env file": os.path.exists(os.path.join(ROOT_DIR, 'secrets', '.env')),
    }
    
    print("\n--- Status Report ---")
    all_ok = all(checks.values())
    for check, result in checks.items():
        print(f"- {check}: {'‚úÖ OK' if result else '‚ùå FAILED / MISSING'}")
    
    if not checks["Secrets .env file"]:
        print("\nWarning: No 'secrets/.env' file found. Servers might not work correctly without API keys.")
    
    if all_ok:
        print("\nEnvironment check successful!")
    else:
        print("\nSome environment checks failed. Please review the messages above.")

def main():
    """Main function to display the menu and handle user input."""
    menu = {
        '1': ('Install Dependencies', install_dependencies),
        '2': ('Run Python API & Auth Server', run_python_server),
        '3': ('Run Frontend Dev Server', run_frontend_dev_server),
        '4': ('Run All Services (Concurrent)', run_all_services),
        '5': ('Check Environment', check_environment),
        '6': ('Exit', lambda: sys.exit(0)),
    }
    while True:
        print_header("Developer Task Runner")
        for k, (text, _) in menu.items():
            print(f"{k}. {text}")
        choice = input("Select an option: ").strip()
        action = menu.get(choice)
        if action:
            try:
                action[1]()
            except KeyboardInterrupt:
                print("\nOperation interrupted by user.")
        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    try:
        main()
    except (KeyboardInterrupt, SystemExit):
        print("\nTask runner stopped. Exiting.")
        sys.exit(0)
