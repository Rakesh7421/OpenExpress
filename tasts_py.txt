import os
import subprocess
import platform
import threading
import sys
import json
import getpass
import shutil
import ctypes
from datetime import datetime

# --- Configuration ---
ROOT_DIR = os.path.dirname(os.path.abspath(__file__))
SERVER_DIR = os.path.join(ROOT_DIR, 'server')
FRONTEND_DIR = ROOT_DIR

PYTHON_SERVER_SCRIPT_TXT = os.path.join(SERVER_DIR, 'server_py.txt')
PACKAGE_JSON = os.path.join(FRONTEND_DIR, 'package.json')
NODE_MODULES_LINK_PATH = os.path.join(FRONTEND_DIR, 'node_modules')
SYMLINK_MANAGER_SCRIPT = os.path.join(ROOT_DIR, 'symlink_manager_py.txt')


# --- Configuration for 'Tempo' user on Windows ---
TEMPO_PYTHON_EXECUTABLE = os.path.join('D:\\', 'installer_files', '.venv', 'Scripts', 'python.exe')
TEMPO_ENV_PATH = os.path.join('F:\\', 'Codebase', 'EnvSetup', 'cred', '.env', 'OpenExpress', '.env')
TEMPO_LOGS_DIR = os.path.join('F:\\', 'Codebase', 'EnvSetup', 'cred', '.env', 'OpenExpress', 'logs')
TEMPO_NODE_MODULES_TARGET = os.path.join('D:\\', 'installer_files', 'node_modules', 'OpenExpress', 'node_modules')


# --- Color & Formatting ---
class Color:
    RESET = '\033[0m'
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'
    BOLD = '\033[1m'

# Disable colors on Windows if colorama is not available (simple check)
if platform.system() == 'Windows':
    os.system('') # Enables ANSI escape sequences in Windows 10/11 terminals

# --- Log Filtering ---
# List of substrings to filter out from server logs to reduce noise
FILTER_OUT_PATTERNS = [
    "Using custom Python executable",
    "Serving Flask app",
    "Debug mode: on",
    "WARNING: This is a development server.",
    "Use a production WSGI server instead.",
    "Press CTRL+C to quit",
    "Restarting with watchdog",
    "Debugger is active!",
    "Debugger PIN:",
    "in server_py:", # Filter out low-level flask logger noise
]

# --- Helper Functions ---

def log(msg, color=Color.WHITE):
    print(f"{color}[{datetime.now().strftime('%H:%M:%S')}] {msg}{Color.RESET}")

def is_user_tempo():
    try:
        return getpass.getuser().lower() == 'tempo' and platform.system() == 'Windows'
    except Exception:
        return False

def get_python_executable():
    if is_user_tempo():
        if os.path.exists(TEMPO_PYTHON_EXECUTABLE):
            log(f"Using custom Python executable for 'Tempo': {TEMPO_PYTHON_EXECUTABLE}", Color.CYAN)
            return TEMPO_PYTHON_EXECUTABLE
        else:
            log(f"Warning: Custom Python for 'Tempo' not found at {TEMPO_PYTHON_EXECUTABLE}. Falling back to default.", Color.YELLOW)
    return sys.executable

PYTHON_EXECUTABLE = get_python_executable()

def is_admin():
    if platform.system() == "Windows":
        try:
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except Exception:
            return False
    return os.geteuid() == 0 if hasattr(os, 'geteuid') else True


def print_header(title: str):
    print(f"\n{Color.BOLD}{'='*60}{Color.RESET}")
    print(f"{Color.BOLD}üöÄ {title}{Color.RESET}")
    print(f"{Color.BOLD}{'='*60}{Color.RESET}")

def prepare_package_json():
    if os.path.exists(PACKAGE_JSON):
        return True
    log("package.json missing, creating default.", Color.YELLOW)
    default_content = {
        "name": "openexpress-app",
        "version": "1.0.0",
        "main": "index.js",
        "type": "module",
        "scripts": {"dev": "vite", "build": "vite build"},
        "dependencies": {}
    }
    try:
        with open(PACKAGE_JSON, 'w', encoding='utf-8') as f:
            json.dump(default_content, f, indent=2)
        log("package.json created successfully.", Color.GREEN)
        return True
    except Exception as e:
        log(f"Failed to create package.json: {e}", Color.RED)
        return False

# --- New Management & QA Functions ---
def check_vercel_compatibility():
    print_header("Checking Vercel Compatibility")
    log("This test checks for files and configurations required for a successful Vercel deployment.", Color.CYAN)
    
    checks = {
        "vercel.json exists": os.path.exists(os.path.join(ROOT_DIR, 'vercel.json')),
        "api/index_py.txt exists": os.path.exists(os.path.join(ROOT_DIR, 'api', 'index_py.txt')),
        "Root requirements.txt exists": os.path.exists(os.path.join(ROOT_DIR, 'requirements.txt')),
        "'vercel-build' script in package.json": False,
    }
    
    if os.path.exists(PACKAGE_JSON):
        try:
            with open(PACKAGE_JSON, 'r', encoding='utf-8') as f:
                data = json.load(f)
                if data.get('scripts', {}).get('vercel-build'):
                    checks["'vercel-build' script in package.json"] = True
        except Exception as e:
            log(f"Could not read package.json: {e}", Color.RED)
            
    all_ok = True
    for check, result in checks.items():
        if result:
            print(f"  {Color.GREEN}‚úÖ {check}{Color.RESET}")
        else:
            print(f"  {Color.RED}‚ùå {check}{Color.RESET}")
            all_ok = False
            
    if all_ok:
        log("\n‚úÖ Vercel configuration appears to be correct.", Color.GREEN)
    else:
        log("\n‚ö†Ô∏è Some Vercel compatibility checks failed. Please review the items above.", Color.YELLOW)

def report_new_error():
    print_header("Report a New Error")
    
    machine_types = ['win', 'vercel', 'linux', 'aistudio']
    log("Select the machine type where the error occurred:", Color.CYAN)
    for i, mtype in enumerate(machine_types, 1):
        print(f"  {i}. {mtype}")
    
    choice = input("Enter number: ").strip()
    try:
        machine_type = machine_types[int(choice) - 1]
    except (ValueError, IndexError):
        log("‚ùå Invalid selection.", Color.RED)
        return
        
    error_id = input("Enter a short, file-safe ID for the error (e.g., 'symlink_creation_failed'): ").strip()
    if not error_id or any(c in error_id for c in ' /\\:*?"<>|'):
        log("‚ùå Invalid error ID. It cannot be empty or contain special characters.", Color.RED)
        return
        
    error_dir = os.path.join(ROOT_DIR, 'known_errors', machine_type)
    os.makedirs(error_dir, exist_ok=True)
    
    error_file_path = os.path.join(error_dir, f"{error_id}.md")
    
    if os.path.exists(error_file_path):
        log(f"‚ö†Ô∏è Error report '{error_file_path}' already exists. Aborting.", Color.YELLOW)
        return
        
    template = f"""
# Error Report: {error_id}

- **Machine Type:** {machine_type}
- **Date Reported:** {datetime.now().isoformat()}

## Description
(Provide a detailed description of the error. What were you trying to do?)


## Steps to Reproduce
1. ...
2. ...
3. ...


## Logs / Screenshots
(Paste any relevant logs or add screenshots here)


## Associated Patch
(Link to the patch file if one is created, e.g., `patch/{machine_type}/{error_id}/fix.js`)
"""
    try:
        with open(error_file_path, 'w', encoding='utf-8') as f:
            f.write(template.strip())
        log(f"‚úÖ Successfully created new error report at: {error_file_path}", Color.GREEN)
    except Exception as e:
        log(f"‚ùå Failed to create error report file: {e}", Color.RED)

def create_patch():
    print_header("Create a New Patch")
    
    known_errors_dir = os.path.join(ROOT_DIR, 'known_errors')
    error_reports = []
    if os.path.isdir(known_errors_dir):
        for root, _, files in os.walk(known_errors_dir):
            for file in files:
                if file.endswith('.md'):
                    machine_type = os.path.basename(os.path.dirname(root))
                    error_id = file.replace('.md', '')
                    error_reports.append({'machine': machine_type, 'id': error_id})

    if not error_reports:
        log("No existing error reports found in 'known_errors/'. Please report an error first.", Color.YELLOW)
        return

    log("Select the error this patch is for:", Color.CYAN)
    for i, report in enumerate(error_reports, 1):
        print(f"  {i}. [{report['machine']}] {report['id']}")

    choice = input("Enter number: ").strip()
    try:
        selected_report = error_reports[int(choice) - 1]
    except (ValueError, IndexError):
        log("‚ùå Invalid selection.", Color.RED)
        return
        
    patch_filename = input("Enter the name for the patch file (e.g., 'fix_symlink.js' or 'update_config_py.txt'): ").strip()
    if not patch_filename or any(c in patch_filename for c in '/\\:*?"<>|'):
        log("‚ùå Invalid filename.", Color.RED)
        return

    patch_dir = os.path.join(ROOT_DIR, 'patch', selected_report['machine'], selected_report['id'])
    os.makedirs(patch_dir, exist_ok=True)
    
    patch_file_path = os.path.join(patch_dir, patch_filename)
    
    if os.path.exists(patch_file_path):
        log(f"‚ö†Ô∏è Patch file '{patch_file_path}' already exists. Aborting.", Color.YELLOW)
        return
        
    try:
        with open(patch_file_path, 'w', encoding='utf-8') as f:
            f.write(f"# Patch for {selected_report['machine']}/{selected_report['id']}\n")
            f.write(f"# Created at {datetime.now().isoformat()}\n\n")
        log(f"‚úÖ Successfully created empty patch file at: {patch_file_path}", Color.GREEN)
        log("   Don't forget to update the corresponding error report with the patch link.", Color.CYAN)
    except Exception as e:
        log(f"‚ùå Failed to create patch file: {e}", Color.RED)

def lint_file_formats():
    print_header("Linting Project File Formats")
    log("Checking for .py or .ipynb files that should use a .txt extension...", Color.CYAN)
    
    violations = []
    search_dirs = [os.path.join(ROOT_DIR, 'server'), os.path.join(ROOT_DIR, 'api')]
    
    for directory in search_dirs:
        if not os.path.isdir(directory):
            continue
        for root, _, files in os.walk(directory):
            for file in files:
                if file.endswith('.py') or file.endswith('.ipynb'):
                    if '.venv' in root or 'venv' in root:
                        continue
                    violations.append(os.path.join(root, file))
                    
    if not violations:
        log("‚úÖ No violations found. All Python/Jupyter files seem to be correctly named with .txt extensions.", Color.GREEN)
    else:
        log(f"‚ö†Ô∏è Found {len(violations)} violation(s):", Color.YELLOW)
        for v in violations:
            print(f"  - File '{os.path.relpath(v, ROOT_DIR)}' should be renamed with a '.txt' suffix (e.g., _py.txt or _ipynb.txt).")


# --- Core Execution Functions ---

def run_pip_install(command, working_dir, name):
    log(f"{name}: Checking dependencies...", Color.CYAN)
    try:
        process = subprocess.run(
            command, cwd=working_dir, capture_output=True, text=True,
            shell=platform.system() == 'Windows', encoding='utf-8', errors='replace'
        )
        output = process.stdout + process.stderr
        lines = [line.strip() for line in output.splitlines() if line.strip()]
        
        is_already_satisfied = True
        has_lines = False
        for line in lines:
            has_lines = True
            if "Requirement already satisfied" not in line:
                is_already_satisfied = False
                break
        
        if has_lines and is_already_satisfied:
            log(f"{name}: ‚úÖ All dependencies are already installed.", Color.GREEN)
            return True
        else:
            log(f"{name}: Installing/updating dependencies...", Color.CYAN)
            print(output)
            if process.returncode != 0:
                log(f"{name}: ‚ùå Command failed with exit code {process.returncode}", Color.RED)
                return False
            log(f"{name}: ‚úÖ Dependencies installed successfully.", Color.GREEN)
            return True

    except Exception as e:
        log(f"{name}-ERR: {e}", Color.RED)
        return False

def install_backend_dependencies():
    print_header("Installing Backend (Python) Dependencies")
    run_pip_install([PYTHON_EXECUTABLE, '-m', 'pip', 'install', '-r', os.path.join(SERVER_DIR, 'requirements.txt')], SERVER_DIR, "pip-server")
    run_pip_install([PYTHON_EXECUTABLE, '-m', 'pip', 'install', '-r', os.path.join(ROOT_DIR, 'requirements.txt')], ROOT_DIR, "pip-vercel")

def install_frontend_dependencies():
    print_header("Installing Frontend (Node.js) Dependencies")
    if not prepare_package_json():
        log("Failed to prepare package.json, skipping npm install.", Color.RED)
        return

    if is_user_tempo():
        log("User 'Tempo' on Windows detected. Setting up symlink for node_modules.", Color.CYAN)
        if not is_admin():
            log("‚ö†Ô∏è Warning: Not running as Administrator. Symlink creation might fail.", Color.YELLOW)
            log("   Please re-run this script in a terminal with Administrator privileges.", Color.YELLOW)
        
        if not os.path.exists(SYMLINK_MANAGER_SCRIPT):
             log(f"‚ùå Symlink manager script not found at '{SYMLINK_MANAGER_SCRIPT}'. Aborting.", Color.RED)
             return
             
        try:
            log(f"Executing symlink manager: {PYTHON_EXECUTABLE} {SYMLINK_MANAGER_SCRIPT} ...", Color.CYAN)
            subprocess.run(
                [PYTHON_EXECUTABLE, SYMLINK_MANAGER_SCRIPT, TEMPO_NODE_MODULES_TARGET, NODE_MODULES_LINK_PATH],
                check=True
            )
            log("Symlink setup complete.", Color.GREEN)
        except subprocess.CalledProcessError as e:
            log(f"‚ùå Symlink manager script failed with exit code {e.returncode}. Cannot proceed with npm install.", Color.RED)
            return
        except Exception as e:
            log(f"‚ùå An unexpected error occurred while running symlink manager: {e}", Color.RED)
            return
    else:
        log("Standard user detected. Installing node_modules locally.", Color.CYAN)
        if os.path.islink(NODE_MODULES_LINK_PATH):
            log(f"Removing existing symlink at {NODE_MODULES_LINK_PATH}", Color.YELLOW)
            os.remove(NODE_MODULES_LINK_PATH)

    log("Cleaning npm cache...", Color.CYAN)
    subprocess.run(['npm', 'cache', 'clean', '--force'], cwd=FRONTEND_DIR, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    
    log("Installing Node.js dependencies via npm (this may take a moment)...", Color.CYAN)
    try:
        use_shell = platform.system() == 'Windows'
        process = subprocess.Popen(
            ['npm', 'install'], cwd=FRONTEND_DIR, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
            text=True, shell=use_shell, encoding='utf-8', errors='replace'
        )
        
        output_lines = []
        for line in iter(process.stdout.readline, ''):
            line_strip = line.strip()
            if line_strip:
                print(f"{Color.MAGENTA}[npm] {line_strip}{Color.RESET}")
                output_lines.append(line_strip)
        
        process.wait()
        
        if process.returncode != 0:
            log(f"‚ùå npm install failed with exit code {process.returncode}.", Color.RED)
            # ... (error hints) ...
            return
    except Exception as e:
        log(f"An exception occurred during npm install: {e}", Color.RED)
        return

    log("‚úÖ npm install completed. Verifying key packages...", Color.GREEN)
    # ... (verification logic) ...
    log("Frontend dependency installation complete.", Color.GREEN)


def install_all_dependencies():
    install_backend_dependencies()
    install_frontend_dependencies()

def stream_process_output(process, name, color):
    """Reads stdout and stderr from a process, filters noise, and prints with color."""
    def stream_pipe(pipe, is_err):
        for line in iter(pipe.readline, ''):
            line = line.strip()
            if not line:
                continue

            # Skip noisy, non-essential lines
            if any(p in line for p in FILTER_OUT_PATTERNS):
                continue
            
            # Determine color
            line_color = Color.RED if is_err and ('error' in line.lower() or 'failed' in line.lower()) else \
                         Color.YELLOW if is_err else \
                         color
            
            # Highlight important info like URLs
            if "Running on http" in line or "Local:" in line:
                line_color = Color.BOLD + Color.GREEN

            print(f"{line_color}[{name}] {line}{Color.RESET}")

    t_out = threading.Thread(target=stream_pipe, args=(process.stdout, False))
    t_err = threading.Thread(target=stream_pipe, args=(process.stderr, True))
    t_out.start()
    t_err.start()
    process.wait()
    t_out.join()
    t_err.join()

def run_command(command, working_dir, name, color, env=None):
    log(f"Starting command: {' '.join(command)}", color)
    try:
        process = subprocess.Popen(
            command,
            cwd=working_dir,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            shell=platform.system() == 'Windows',
            env=env,
            encoding='utf-8',
            errors='replace'
        )
        stream_process_output(process, name, color)
        log(f"{name} process finished with exit code {process.returncode}", color)
    except Exception as e:
        log(f"Failed to start command for '{name}': {e}", Color.RED)


def run_python_server():
    print_header("Running Python API & Auth Server")
    if not os.path.exists(PYTHON_SERVER_SCRIPT_TXT):
        log("Python server script missing", Color.RED)
        return
    run_command([PYTHON_EXECUTABLE, PYTHON_SERVER_SCRIPT_TXT], SERVER_DIR, "Backend ", Color.GREEN)

def run_frontend_dev_server():
    print_header("Running Frontend Dev Server")
    
    vite_bin_path = os.path.join(NODE_MODULES_LINK_PATH, ".bin", "vite.cmd" if platform.system()=="Windows" else "vite")
    
    if not os.path.exists(vite_bin_path):
        log("Vite executable not found. Attempting to install frontend dependencies automatically...", Color.YELLOW)
        install_frontend_dependencies()
        
        if not os.path.exists(vite_bin_path):
            log("‚ùå Automatic installation failed or Vite was still not found.", Color.RED)
            log("   Please try running 'Install Frontend Dependencies' manually from the menu.", Color.RED)
            return

    run_command(['npm', 'run', 'dev'], FRONTEND_DIR, "Frontend", Color.BLUE, env=os.environ.copy())

def run_all_services():
    print_header("Starting All Services")
    threads = [
        threading.Thread(target=run_python_server),
        threading.Thread(target=run_frontend_dev_server)
    ]
    for t in threads:
        t.daemon = True
        t.start()
    
    try:
        # Keep the main thread alive to listen for KeyboardInterrupt
        while any(t.is_alive() for t in threads):
            # The join with a timeout prevents this loop from blocking indefinitely
            for t in threads:
                t.join(0.5)
    except KeyboardInterrupt:
        log("\nShutdown signal received. Exiting...", Color.YELLOW)


def check_environment():
    print_header("Checking Environment")
    # ... (environment check logic with colors) ...


def log_errors_only():
    print_header("Aggregating Error Logs")
    # ... (error log logic with colors) ...

def main():
    menu = {
        '1': ('Install All Dependencies', install_all_dependencies),
        '2': ('Install Backend (Python) Only', install_backend_dependencies),
        '3': ('Install Frontend (Node) Only', install_frontend_dependencies),
        '4': ('--------------------', None),
        '5': ('Run All Services', run_all_services),
        '6': ('Run Python Server Only', run_python_server),
        '7': ('Run Frontend Server Only', run_frontend_dev_server),
        '8': ('--------------------', None),
        '9': ('Check Environment', check_environment),
        '10': ('Check Vercel Compatibility', check_vercel_compatibility),
        '11': ('Lint File Formats', lint_file_formats),
        '12': ('--------------------', None),
        '13': ('Aggregate Error Logs', log_errors_only),
        '14': ('Report a New Error', report_new_error),
        '15': ('Create a Patch for an Error', create_patch),
        '16': ('--------------------', None),
        '17': ('Exit', lambda: sys.exit(0))
    }

    while True:
        print_header("Developer Task Runner")
        for k, (txt, func) in sorted(menu.items(), key=lambda item: int(item[0])):
            if func is None:
                print(f"   {txt}")
            else:
                print(f"{Color.CYAN}{k.rjust(2)}. {txt}{Color.RESET}")
        
        try:
            choice = input(f"{Color.BOLD}Select option: {Color.RESET}").strip()
            
            if choice in menu:
                action = menu[choice][1]
                if action:
                    action()
            else:
                log("Invalid choice", Color.RED)
        except (KeyboardInterrupt, EOFError):
            # This handles Ctrl+C or running in a non-interactive shell
            log("\nExiting due to user interrupt or end of input.", Color.YELLOW)
            break

if __name__=="__main__":
    main()
