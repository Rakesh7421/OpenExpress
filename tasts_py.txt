import os
import subprocess
import platform
import threading
import sys
import json
import shutil
import atexit
from typing import List, Optional

# --- Configuration ---
ROOT_DIR = os.path.dirname(os.path.abspath(__file__))
SERVER_DIR = os.path.join(ROOT_DIR, 'server')
FRONTEND_DIR = ROOT_DIR

PYTHON_SERVER_SCRIPT_TXT = os.path.join(SERVER_DIR, 'server_py.txt')
NODE_AUTH_SERVER_SCRIPT = os.path.join(SERVER_DIR, 'auth.js')
PACKAGE_JSON_TXT = os.path.join(SERVER_DIR, 'package_json.txt')
PACKAGE_JSON = os.path.join(ROOT_DIR, 'package.json')
TEMP_PYTHON_SCRIPT = os.path.join(SERVER_DIR, '_temp_server_runner.py')

# --- Helper Functions ---

def print_header(title: str):
    """Prints a styled header."""
    print("\n" + "=" * 50)
    print(f"üöÄ {title}")
    print("=" * 50)

def cleanup_temp_files():
    """Removes temporary files created by the script."""
    if os.path.exists(TEMP_PYTHON_SCRIPT):
        try:
            os.remove(TEMP_PYTHON_SCRIPT)
            print("\n[Cleanup] Removed temporary Python script.")
        except OSError as e:
            print(f"\n[Cleanup-ERR] Error removing temporary file: {e}")

# Register the cleanup function to run on script exit
atexit.register(cleanup_temp_files)

def prepare_package_json():
    """Ensures package.json exists, creating it from the template if needed."""
    if os.path.exists(PACKAGE_JSON):
        return True
    if os.path.exists(PACKAGE_JSON_TXT):
        print(f"Info: '{os.path.basename(PACKAGE_JSON)}' not found. Creating it from template...")
        try:
            shutil.copy(PACKAGE_JSON_TXT, PACKAGE_JSON)
            print(f"Successfully created '{os.path.relpath(PACKAGE_JSON, ROOT_DIR)}'.")
            return True
        except Exception as e:
            print(f"Error: Could not create package.json. Reason: {e}")
            return False
    return False

def update_package_json_for_esm():
    """Ensures package.json has 'type: module' for ES module support."""
    if not os.path.exists(PACKAGE_JSON):
        return False
    try:
        with open(PACKAGE_JSON, 'r+') as f:
            data = json.load(f)
            if data.get('type') != 'module':
                print("Info: Adding '\"type\": \"module\"' to package.json for Node.js ES Module support.")
                data['type'] = 'module'
                f.seek(0)
                json.dump(data, f, indent=2)
                f.truncate()
    except (json.JSONDecodeError, IOError) as e:
        print(f"Error reading or updating package.json: {e}")
        return False
    return True

def run_command(command: List[str], working_dir: str, name: str, env: Optional[dict] = None):
    """Runs a command in a subprocess and streams its output."""
    print(f"[{name}] Starting process: {' '.join(command)}")
    try:
        use_shell = platform.system() == 'Windows'
        process = subprocess.Popen(
            command, cwd=working_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            text=True, encoding='utf-8', errors='replace', env=env, shell=use_shell
        )
        def stream_output(pipe, prefix):
            if pipe:
                for line in iter(pipe.readline, ''):
                    print(f"{prefix} {line}", end='')
        
        stdout_thread = threading.Thread(target=stream_output, args=(process.stdout, f"[{name}]"))
        stderr_thread = threading.Thread(target=stream_output, args=(process.stderr, f"[{name}-ERR]"))
        stdout_thread.start()
        stderr_thread.start()
        process.wait()
        stdout_thread.join()
        stderr_thread.join()
        print(f"[{name}] Process finished with exit code {process.returncode}.")
    except FileNotFoundError:
        print(f"[{name}-ERR] Command not found: {command[0]}. Is it installed and in your PATH?")
    except Exception as e:
        print(f"[{name}-ERR] An error occurred: {e}")

# --- Task Functions ---

def install_dependencies():
    """Installs both Python and Node.js dependencies."""
    print_header("Installing Dependencies")
    
    print("\n--- Installing Python dependencies ---")
    run_command([sys.executable, '-m', 'pip', 'install', '-r', 'requirements.txt'], SERVER_DIR, "pip")
    
    print("\n--- Installing Node.js dependencies ---")
    if not prepare_package_json():
        print("[npm-ERR] Could not prepare package.json. Skipping npm install.")
        return
    run_command(['npm', 'install'], FRONTEND_DIR, "npm")

def run_python_server():
    """Runs the Python/Flask API server using a temporary script."""
    print_header("Running Python Flask Server")
    if not os.path.exists(PYTHON_SERVER_SCRIPT_TXT):
        print(f"[{'Python API'}-ERR] Source file not found: {os.path.relpath(PYTHON_SERVER_SCRIPT_TXT, ROOT_DIR)}")
        return
        
    try:
        shutil.copy(PYTHON_SERVER_SCRIPT_TXT, TEMP_PYTHON_SCRIPT)
        env = os.environ.copy()
        env['PORT'] = '8080'
        env['FLASK_APP'] = os.path.basename(TEMP_PYTHON_SCRIPT)
        env['FLASK_ENV'] = 'development'
        command = [sys.executable, TEMP_PYTHON_SCRIPT]
        run_command(command, ROOT_DIR, "Python API", env)
    finally:
        cleanup_temp_files()

def run_node_auth_server():
    """Runs the Node.js/Express authentication server."""
    print_header("Running Node.js Auth Server")
    if not os.path.exists(NODE_AUTH_SERVER_SCRIPT):
        print(f"[{'Node Auth'}-ERR] Script not found: {os.path.relpath(NODE_AUTH_SERVER_SCRIPT, ROOT_DIR)}")
        return
    if not prepare_package_json() or not update_package_json_for_esm():
        print("Could not prepare package.json for Node.js server. Aborting.")
        return

    env = os.environ.copy()
    env['PORT'] = '3001'
    run_command(['node', NODE_AUTH_SERVER_SCRIPT], ROOT_DIR, "Node Auth", env)

def run_frontend_dev_server():
    """Runs the frontend development server (Vite)."""
    print_header("Running Frontend Dev Server")
    if not os.path.exists(PACKAGE_JSON):
        print("[Frontend-ERR] package.json not found. Cannot start. Try running 'Install Dependencies' first.")
        return
    run_command(['npm', 'run', 'dev'], FRONTEND_DIR, "Frontend")

def run_all_services():
    """Runs all services concurrently in separate threads."""
    print_header("Starting All Services")

    # Pre-flight check before starting threads
    if not all(os.path.exists(p) for p in [PYTHON_SERVER_SCRIPT_TXT, NODE_AUTH_SERVER_SCRIPT, PACKAGE_JSON]):
         print("\nOne or more required script files are missing. Run 'Check Environment' for details.")
         return

    threads = [
        threading.Thread(target=run_python_server),
        threading.Thread(target=run_node_auth_server),
        threading.Thread(target=run_frontend_dev_server)
    ]
    
    for t in threads:
        t.start()
    
    try:
        for t in threads:
            t.join()
    except KeyboardInterrupt:
        print("\nCaught KeyboardInterrupt, stopping services...")

def check_environment():
    """Checks for necessary files and configurations."""
    print_header("Checking Environment")
    
    pkg_json_ok = prepare_package_json()
    esm_ok = update_package_json_for_esm() if pkg_json_ok else False

    checks = {
        "Python Server Source (server_py.txt)": os.path.exists(PYTHON_SERVER_SCRIPT_TXT),
        "Node Auth Script (auth.js)": os.path.exists(NODE_AUTH_SERVER_SCRIPT),
        "package.json in root": pkg_json_ok,
        "package.json ESM config": esm_ok,
        "Python requirements.txt": os.path.exists(os.path.join(SERVER_DIR, 'requirements.txt')),
        "Secrets .env file": os.path.exists(os.path.join(ROOT_DIR, 'secrets', '.env')),
    }
    
    print("\n--- Status Report ---")
    all_ok = all(checks.values())
    for check, result in checks.items():
        print(f"- {check}: {'‚úÖ OK' if result else '‚ùå FAILED / MISSING'}")
    
    if not checks["Secrets .env file"]:
        print("\nWarning: No 'secrets/.env' file found. Servers might not work correctly without API keys.")
    
    if all_ok:
        print("\nEnvironment check successful!")
    else:
        print("\nSome environment checks failed. Please review the messages above.")

def main():
    """Main function to display the menu and handle user input."""
    menu = {
        '1': ('Install Dependencies', install_dependencies),
        '2': ('Run Python API Server', run_python_server),
        '3': ('Run Node.js Auth Server', run_node_auth_server),
        '4': ('Run Frontend Dev Server', run_frontend_dev_server),
        '5': ('Run All Services (Concurrent)', run_all_services),
        '6': ('Check Environment', check_environment),
        '7': ('Exit', lambda: sys.exit(0)),
    }
    while True:
        print_header("Developer Task Runner")
        for k, (text, _) in menu.items():
            print(f"{k}. {text}")
        choice = input("Select an option: ").strip()
        action = menu.get(choice)
        if action:
            try:
                action[1]()
            except KeyboardInterrupt:
                print("\nOperation interrupted by user.")
        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    try:
        main()
    except (KeyboardInterrupt, SystemExit):
        print("\nTask runner stopped. Exiting.")
        sys.exit(0)
